{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"docs/index.md","text":""},{"location":"#hello","title":"Hello!","text":"<p>Welcome to my site.</p> <p>I built a couple of 3D simulations in Glowscript (VPython).</p> <p>The goal is to help you out if you're trying to build something similar.</p> <p>Feel free to steal the code!</p>"},{"location":"#the-projects","title":"The Projects","text":"<ol> <li>The Entropy Cube: A big box made of smaller boxes that light up based on how many particles are bouncing around inside them.</li> <li>The Fire Sim: Fancy fire simulation, actually calculating entropy using Boltzmann's formula.</li> </ol>"},{"location":"entropy_cube/","title":"The Entropy Cube","text":"<p>can you </p>"},{"location":"entropy_cube/#docsentropy_cubemd","title":"docs/entropy_cube.md","text":""},{"location":"entropy_cube/#project-1-the-entropy-cube","title":"Project 1: The 'Entropy Cube'","text":"<p>This is a box. It has tiny balls in it. The box is also made of a bunch of smaller boxes, and they light up based on how many balls are inside them.</p> <p>That's pretty much it. My simple way of \"seeing\" entropy. If all the balls are in one corner (low entropy), that corner will be bright red. If they're all spread out (high entropy), the whole box will be a nice, even color. I thought about using a python package called fast_boltzmann to actually calculate the entropy, but I never actually got around to doing it. Maybe another time.</p>"},{"location":"entropy_cube/#anyway-go-play-with-it","title":"Anyway. Go play with it!","text":""},{"location":"entropy_cube/#how-it-works","title":"How It Works","text":""},{"location":"entropy_cube/#1-making-the-grid-the-hard-way","title":"1. Making the Grid (The Hard Way)","text":"<p>At first, I just made a bunch of cubes using VPython's <code>box()</code> object. Super simple. This was a mistake.</p> <p>I realized I couldn't color each individual cube. The solution was a pain, but it works: I had to build every single tiny cubelet manually out of 6 faces. Each \"face\" is just a <code>box()</code> object that's really, really thin.</p> <p><pre><code># This is inside a giant triple-loop (for i, j, k)\nCUBELET_SIZE = CONTAINER_SIZE / GRID_DIMENSION\nFACE_THICKNESS = 0.05\nhs = CUBELET_SIZE / 2 # hs just stands for \"half-size\"\n\nfaces = {\n    'left':   box(pos=pos - vector(hs, 0, 0), size=vector(FACE_THICKNESS, CUBELET_SIZE, CUBELET_SIZE), opacity=0.2),\n    'right':  box(pos=pos + vector(hs, 0, 0), size=vector(FACE_THICKNESS, CUBELET_SIZE, CUBELET_SIZE), opacity=0.2),\n    'bottom': box(pos=pos - vector(0, hs, 0), size=vector(CUBELET_SIZE, FACE_THICKNESS, CUBELET_SIZE), opacity=0.2),\n    # ...and so on for top, back, and front\n}\n</code></pre> This way, I can store all 6 faces for grid[i][j][k] and then color them however I want.</p>"},{"location":"entropy_cube/#2-the-shell-view","title":"2. The \"Shell View\"","text":"<p>Fun little button. How do you see inside? Just make all the internal faces invisible. Just checks which faces are on the edge</p> <p>Simple, but it looks pretty cool.</p>"},{"location":"entropy_cube/#3-the-entropy-color","title":"3. The \"Entropy\" Color","text":"<p>This is the main logic, running every single frame:</p> <p>Count: Make a big 3D list full of zeros. Loop through every particle, figure out which (i, j, k) cubelet it's in, and add +1 to that cube's counter.</p> <p>Calculate: Loop through all the counts. I use a simple formula (-prob * log(prob)) to get an \"entropy\" value. I also find the highest entropy value in the whole grid (max_entropy).</p> <p>Color: I \"normalize\" the value by dividing it by max_entropy. This gives me a number between 0 and 1. I turn that number into a color (0 is blue, 0.5 is green, 1 is red).</p> <p>Apply: I take that color and apply it to all 6 faces of that cubelet.</p> <p>And that's it! The particles just bounce off the walls, and the grid just colors itself based on where they are.</p>"},{"location":"fire_simulation/","title":"docs/fire_simulation.md","text":""},{"location":"fire_simulation/#project-2-the-fire-sim","title":"Project 2: The Fire Sim","text":"<p>This one was a lot harder, still fun tho. It's a particle simulation that actually tries to look and \"feel\" like a campfire.</p> <p>It's got physics, color blending, and a few clever tricks to run fast and look good. It even calculates the real Boltzmann Entropy of the fire, which is some pretty high-level stuff.</p>"},{"location":"fire_simulation/#play-with-it","title":"Play With It!","text":"<p>Make sure to toggle \"Show Entropy Bins\", it took to long to implement for noone to see it</p>"},{"location":"fire_simulation/#the-interesting-bits","title":"The Interesting Bits","text":"<p>I learned some cool stuff making this</p>"},{"location":"fire_simulation/#1-particle-pooling-aka-recycling","title":"1. Particle Pooling (aka Recycling)","text":"<p>If you have 2000 particles, creating a new one and destroying an old one every frame is slow. It will kill your browser.</p> <p>The Solution: Particle Pooling. Never destroy a particle. When a particle gets old and \"dies\" (its <code>age</code> is greater than its <code>lifetime</code>), we just call <code>reset_particle(p)</code>. This function instantly teleports it back to the bottom of the fire, gives it a new random velocity and lifetime, and makes it visible again.</p> <p>It looks like a new particle, but it's just an old one being recycled. It's way, way faster.</p>"},{"location":"fire_simulation/#2-the-bell-curve","title":"2. The Bell Curve","text":"<p>If you just spawn particles at random spots, the fire looks like a square block. Real fire is hotter and denser in the middle.</p> <p>You need a Gaussian (bell curve) distribution for your spawn points. The problem? Glowscript's <code>random</code> module doesn't have a built-in function for this.</p> <p>The Solution: The Box-Muller Transform. It's a weird math trick that uses two normal random numbers (from <code>random()</code>) to create two Gaussian random numbers. I just copied it from a YouTube video, and it works perfectly. It makes particles spawn in the middle way more often than the edges.</p> <pre><code># This is inside the reset_particle() function\nwhile True:\n    r1 = random() + 1e-10  # Can't be zero\n    r2 = random()\n\n    # The magic math voodoo\n    px = GAUSS_STD_DEV * sqrt(-2 * log(r1)) * cos(2 * pi * r2)\n    pz = GAUSS_STD_DEV * sqrt(-2 * log(r1)) * sin(2 * pi * r2)\n\n    p.pos = vector(px, 0, pz)\n\n    # Keep trying until we get one inside the hearth\n    if mag(p.pos) &lt;= hearth_radius:\n        break\n</code></pre>"},{"location":"fire_simulation/#3-the-colors-aka-lerp","title":"3. The Colors (aka \"Lerp\")","text":"<p>How do you smoothly blend from yellow to red? Or from white to blue for a magic fire? You use Linear Interpolation, or \"Lerp\". It's just a function that finds the color between two other colors.</p> <p><pre><code>python\n\ndef mix_colors(color1, color2, fraction):\n    \"\"\"Blends two colour vectors. 'fraction' (0-1) is the mix amount.\"\"\"\n    fraction = max(0, min(1, fraction))\n    return color1 * (1 - fraction) + color2 * fraction\n</code></pre> I use this to blend the start/end colors based on the fire_power slider, and then I use it again to blend that color based on the particle's height.</p>"},{"location":"fire_simulation/#4-the-real-math-boltzmann-entropy","title":"4. The Real Math: Boltzmann Entropy","text":"<p>This was the coolest part. I wanted to calculate the actual entropy of the fire.</p> <p>!!! info \"The Nerdy Stuff I'm not sure even I fully understand</p> <p>The Concept: The famous formula is $S = k_B \\ln(W)$. We ignore $k_B$ (it's a constant). We just need to find $W$, which is the number of ways you can arrange the particles.</p> <p>The Problem: The formula for $W$ is $W = N! / (N_1! \\cdot N_2! \\cdot ...)$ where $N$ is the total particle count and $N_1$, $N_2$ are the counts in each little 1x1x1 bin.</p> <p>This is impossible to calculate. $1000!$ (1000 factorial) is a number with 2,568 digits. Your computer will melt.</p> <p>The Solution: Stirling's Approximation. We don't need $W$, we just need $\\ln(W)$. A very smart dead guy named Stirling figured out an approximation: $\\ln(N!) \\approx N \\ln(N) - N$.</p> <p>If you plug this into the formula for $\\ln(W)$, all the annoying $-N$ terms magically cancel out!</p> <p>The Final Formula: You are left with this beautiful, simple equation that's super fast to calculate:</p> <p>$S \\approx N \\ln(N) - \\sum(N_i \\ln(N_i))$</p> <p>And that's exactly what the code does! <pre><code># N * ln(N)\nn = len(particles)\nentropy = n * log(n) \n\n# Subtract the Sum(Ni * ln(Ni))\nsum_ni_ln_ni = 0\nfor ni in bins.values(): # bins is just a list of counts in each box\n    if ni &gt; 0:\n        sum_ni_ln_ni += ni * log(ni)\n\nentropy -= sum_ni_ln_ni\nentropy_label.text = f'Boltzmann Entropy (S): {entropy:.2f}'\n</code></pre> Resources That Helped Me I didn't invent this, but I learned a lot of stuff. I mostly just watched YouTube. These might help you too.</p> <p>What is Linear Interpolation? (Lerp) https://www.youtube.com/watch?v=YJB1QnEmlTs</p> <p>What is the Box-Muller Transform? https://www.youtube.com/watch?v=4fVQrH65aWU</p> <p>Particle Pooling (Concept) https://www.youtube.com/watch?v=9dp0mAc2vvY</p>"}]}